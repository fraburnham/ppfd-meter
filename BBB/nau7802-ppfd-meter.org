* PPFD meter using 24bit nau7802 ADC

** ADC setup

   ADC Datasheet: http://www.nuvoton.com/resource-files/NAU7802%20Data%20Sheet%20V1.7.pdf
   Naming note: The datasheet refers to registers as ~REGXX[b]~ where ~XX~ is the hex address (0xXX) and ~b~ is the bit
   Registry map starts at section 10 (pg 28).

   The adc is assumed to be connected to i2c-1.

   * Disable
   * Ref voltage select
   * Select internal LDO
   * Power on

   When power is applied the ADC's registers are all 0x0000 (viewed w/ ~i2cdump -y 1 0x2a w~). To init the device write 0x06 to REG0.

   #+begin_src perl :tangle yes :shebang "#!/usr/bin/perl"
     system("i2cset -y 1 0x2a 0x00 0x00");
     system("i2cset -y 1 0x2a 0x01 0x30");
     system("i2cset -y 1 0x2a 0x00 0x86");
     # do validation
   #+end_src

** Reading

   Check the data ready flag in reg 0x00 to avoid reading before data is ready.

   #+begin_src perl :tangle yes
     while(!(hex(`i2cget -y 1 0x2a 0x00`) & 0x20)) {
         # wait for data ready
     }
   #+end_src

   Per datasheet pg 34

   | Register | Result bits      |
   | REG0x12  | bit 23 to bit 16 |
   | REG0x13  | bit 15 to bit 8  |
   | REG0x14  | bit 7 to bit 0   |

   Shift them up then add to get an unsigned 24bit value (will have to use stm32f103 to have big enough integers to avoid fuckery)

   #+begin_src perl :tangle yes
     $high = hex(`i2cget -y 1 0x2a 0x12`);
     $mid = hex(`i2cget -y 1 0x2a 0x13`);
     $low = hex(`i2cget -y 1 0x2a 0x14`);

     $adc_val = ($high << 16) + ($mid << 8) + $low;

     print("Adc val: ", $adc_val, "\n");
   #+end_src

** Translating

   Translate the 24bit adc value into mV then umol/m2/s. The reference voltage is 2.7V. Scale to 2700 for easy mV.
   (Measured voltage is 2.9V, perhaps the best bet would be to read the ref voltage and adjust the scale factor accordingly)

   #+begin_src perl :tangle yes
     $mV = $adc_val * (2900/2**24);
     $umol = 1.6 * $mV;

     print("mV: ", $mV, "\n");
     print("umol/m2/s: ", $umol, "\n");
   #+end_src

** 7seg "library"

   TLC5916 Datasheet (led driver): https://www.ti.com/lit/ds/symlink/tlc5916.pdf

   Per the diagram on p16 of the datasheet, it looks like a 0 value when clock is high sets a pin to sink and a 1 value when clock is high turns that pin off.
   Will do some testing.

   Start out by setting all to 0 or all to 1, then latch enable then output enable.

   Per the datasheet the value is read from SDI on the rising clock edge. The minimum time was 20ns, so basically any wait should be fine at the os level. 
   Should add a 1us wait anyway (if possible).


   Prepare a gpio for output by exporting, setting the direction and returning a handle to the value file (for quicker, more consistent writes).

   #+name: set-output
   #+begin_src perl :noweb yes
     sub setOutput {
         my ($pin) = @_;

         open(my $f, ">", "/sys/class/gpio/export") or die "Failed to export pin $!";
         print $f "$pin";
         close $f;

         open(my $f, ">", "/sys/class/gpio/gpio$pin/direction") or die "Failed to set pin direction $!";
         print $f "out";
         close $f;

         open($f, ">", "/sys/class/gpio/gpio$pin/value") or die "Failed to get handle to pin value $!";
         return $f
     }
   #+end_src

   Given a handle to a value file and a pin number close the value file and unexport the pin.

   #+name: free-pin
   #+begin_src perl :noweb yes
     sub freePin {
         my ($pin, $pinF) = @_;

         close $pinF;

         open(my $f, ">", "/sys/class/gpio/unexport") or die "Failed to unexport pin $!";
         print $f "$pin";
         close $f;
     }
   #+end_src

   Writes a value to a value file. Forcing a flush so the file doesn't have to be closed and the write occurs "immediately". A 1us sleep was added to improve 
   timing consistency. (Though the rise time must be high because ~125us is typical for high state but ~375us is typical for low state. Maybe this is what is killing com w/ the ic)

   #+name: digital-write
   #+begin_src perl :noweb yes
     sub digitalWrite {
         my ($pinF, $value) = @_;

         print $pinF "$value";
         $pinF->flush();
         usleep(1); # hack to keep timing more consistent. Userland gpio is cabbage.
     }
   #+end_src

   Expected pinout:

   | BBP | tlc5916 |
   |  59 | SDI (2) |
   |  58 | CLK (3) |
   |  57 | LE (4)  |
   |  60 | OE (13) |

   | BBB             | tlc5916 |
   | P8_8 (GPIO_67)  | SDI (2) |
   | P8_10 (GPIO_68) | CLK (3) |
   | P8_12 (GPIO_44) | LE (4)  |
   | P8_14 (GPIO_26) | OE (13) |

   OE (output enable) is kept in the state the output pins should be in (high is off, low is on; this is a *sink* ic)

   #+name: prepare-pins
   #+begin_src perl :noweb yes
     my $sdiPin = 67;
     my $clkPin = 68;
     my $lePin = 44;
     my $oePin = 26;

     my $sdi = setOutput($sdiPin);
     my $clk = setOutput($clkPin);
     my $le = setOutput($lePin);
     my $oe = setOutput($oePin);

     digitalWrite($sdi, 0);
     digitalWrite($clk, 0);
     digitalWrite($le, 0);
     digitalWrite($oe, 1);
   #+end_src

   * Set SDI value
   * Clock high
   * Short wait
   * Clock low
   * Repeat above for 8 bits
   * LE high for ??s
   * OE low

   #+name: shift-bit
   #+begin_src perl :noweb yes
     sub shiftBit {
         my ($value) = @_;
         digitalWrite($sdi, $value);
         digitalWrite($clk, 1);
         digitalWrite($clk, 0);
         digitalWrite($sdi, 0);
     }

   #+end_src

   Using the pinout https://electronicsforu.com/resources/7-segment-display-pinout-understanding there map the numbers to their bit values.
   NB: a is bit 0

   #+name: number-bits
   #+begin_src perl :noweb yes
     my %numbers = (
         0 => [0, 0, 1, 1, 1, 1, 1, 1],
         1 => [0, 0, 0, 0, 0, 1, 1, 0],
         2 => [0, 1, 0, 1, 1, 0, 1, 1],
         3 => [0, 1, 0, 0, 1, 1, 1, 1],
         4 => [0, 1, 1, 0, 0, 1, 1, 0],
         5 => [0, 1, 1, 0, 1, 1, 0, 1],
         6 => [0, 1, 1, 1, 1, 1, 0, 1],
         7 => [0, 0, 0, 0, 0, 1, 1, 1],
         8 => [0, 1, 1, 1, 1, 1, 1, 1],
         9 => [0, 1, 1, 0, 1, 1, 1, 1],
     );
   #+end_src

   The digit shifter shifts out each bit.

   Turns out I made the bits above for common cathode and I have common anode. Fun. So there is an inverting step (optionally) by setting ~$commonCathode~ to ~false~.

   #+name: digit-shifter
   #+begin_src perl :noweb yes
     sub shiftDigit {
         my ($digit) = @_;

         digitalWrite($oe, 1);
         
         foreach (0..7) {
             shiftBit($numbers{$digit}[$_]);
         }

         digitalWrite($le, 1);
         digitalWrite($le, 0);

         digitalWrite($oe, 0);
     }
   #+end_src

*** TODO Shift number code (shift a number no matter how many digits)

   #+begin_src perl :tangle 7seg.pl :noweb yes
     use strict;
     use warnings;
     use IO::Handle;
     use Time::HiRes qw(usleep);

     <<number-bits>>

     <<set-output>>
     <<free-pin>>
     <<digital-write>>

     <<prepare-pins>>

     <<shift-bit>>
     <<digit-shifter>>

     foreach (0..9) {
         shiftDigit($_);
         sleep(2);
     }

     sleep(2);

     freePin($sdiPin, $sdi);
     freePin($clkPin, $clk);
     freePin($oePin, $oe);
     freePin($lePin, $le);
   #+end_src
** Outputting values via 4x7seg

   Output the ppfd int part (rounded up) to the 7segs using ~shiftNumber~ 
